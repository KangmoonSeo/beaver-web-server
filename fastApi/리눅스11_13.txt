리눅스 11/13
2023.11.13 월 오전 10:45 ・ 65분 20초
최승혁


참석자 1 00:00
레이직을 하면 나한테 스스로 시그널을 보냅니다.
이펙티브 아이디랑 리얼 아이디가 반드시 같으니까 나한테는 무조건 보낼 수 있을 거고요.
알람은 몇 초 후에 보내는 거 한번 보시고 포즈는 시그널이 누가 보냈건 무슨 시그널이 됐건 상관없이 하나의 시그널이 도착할 때까지 그냥 자는 거예요.
포즈는 시간 정해주는 거 없고요. 내가 포즈를 하면 이 프로세스는 누군가로부터 시그널이 올 때까지 그래서 여기 예제 보면은 포즈 해놓고 알람 해놓고 포즈죠.
알람해놓고 포즈 하는 게 뭐예요? 나 스스로 깨어날 거야.
초 있다가 딱 자기 전에 하는 모닝콜이죠. 나 초 있다가 스스로 자기한테 시그널을 보내서 포즈했던 내가 깨어납니다.
그 예제 그래서 이제 랩 하면 시그널은 대부분의 시그널은 중요한 일이 발생을 했기 때문에 보입니다.
그래서 핸들링을 해줘야 돼요. 디폴트가 디폴트 액션이 있긴 하지만 디폴트 액션은 기본적으로 아주 아주 간단한 일만 합니다.
죽거나 무대하거나 아니면

참석자 1 01:21
아주 최소한의 프린트를 찍어준다거나 세그멘테이션 볼트 해야죠.
다 찍어주죠. 그 정도의 정보만 프린트 해 주거나 이 정도밖에 안 해줘서 시스템 관련된 소프트웨어 그러니까 이제 완전히 하이레벨 유저 소프트웨어가 아니고 하드웨어 기능을 사용하는 소프트웨어를 만들 때는 시그널 관리해줘야 돼요.
시그널 관리를 어떻게 해주는지 우리가 이제 배웠습니다.
여러 가지 시스템 표들이 있으니까 잘 활용하시면 되고요.
질문 있어요 교수님 저 50페이지 이게 지난번에는 이 법이 있다고 하시던데 혹시 다른 데서 오는 건가요? 뭐지? 뭐가 뭐였을까? 기억이 안 나는데요.
내가 수업 끝나고 곰곰히 생각을 해보고 메일 공지에다 올려볼게요.
이거 다 주시네요. 혹시 기억나는 사람 있으면 나한테 메일로 보내요.
다른 질문 있어요 시는 극단 출세도 비슷한 거 발표

참석자 1 02:45
958 9 58 있나 보세요.

참석자 1 03:10
958 입력하시고

참석자 1 03:29
오늘은 내용이 그렇게 많지 않아서 조금 더 일찍 끝날 수 있을 것 같은데 앞에서 했었던 내용들은 이제 다 끝났고 우리 이제 이번 학기 12주차 13주차 14주차 이 세 주 남았는데 오늘 포함해서 인터 프로세스 커뮤니케이션 세 번 하고 끝날 거예요.
원래 이제 커뮤니케이션이 굉장히 중요한 내용인데 여기서 말하는 인터 프로세스 커뮤니케이션은 프로세스 간의 통신이죠.
근데 이제 그냥 상식선에서 통신하면 왠지 네트워크 통해가지고 하는 인터넷 같은 거 떠오르잖아요.
근데 그거는 인 노드 커뮤니케이션이라고 해서 좀 레이어가 달라요.
여기서 인털 프로세스라고 하면 기본적으로는 같은 컴퓨터 안에 있는 프로세스들끼리의 통신을 얘기를 합니다.
이걸 왜 배워야 되냐면 컴퓨터가 대부분 코어가 여러 개죠.
그래서 멀티 프로세싱을 가정하고 있습니다. 멀티프로세싱을 안 하는 소프트웨어는 없다고 얘기를 해도 돼요.
근데 프로세스의 특징이 뭐였죠? 프로세스는 각자 독립적인 메모리 공간을 가지고 있다.
그래서 뭔가

참석자 1 04:41
데이터를 주고받고 싶으면 엑스포리시픽하게 주고받아야 돼요.
반대로 스레드는 스레드 프로세스가 아니고 멀티 프로세스가 아니고 여기 인터 프로세스 얘기하죠 인터 프로세스가 아니고 또 애들끼리는 커뮤니케이션이 어떻게 될까? 커뮤니케이션이라는 개념이 없어요.
어 왜냐면 메모리 공간을 공유하기 때문에 데이터가 보여요.
서로 하는 게 근데 뭘 주고 봐도 그냥 보이기는 할 거고 위급 때문에 그래서 걔네들은 커뮤니케이션이라는 개념이 없고요.
여기서 지금 인터롤 프로세스 커뮤니케이션은 프로세스가 여러 개 있을 때 데이터를 주고받는 방법이고요.
반드시 알아야 멀티프로세싱 을 할 수 있습니다. 멀티 프로세스 커버 소프트웨어를 개발할 수 있어요.
이제 뭘 배울 거냐면 뭐냐 인터페이스에서 커뮤니케이션이 뭐냐 사실 방금 얘기한 게 다을 거예요.
데이터를 프로세스 주고받는 방법이고요. 그리고 파이프랑 파이4 요 두 개를 배울 거예요.
파이프랑 파이4. 파이프는 자료 구조 시간에 이미 배웠죠 뭔지

참석자 1 05:52
똑같아요. 그 파이퍼인데 통신을 위해서 파이퍼라는 이름을 가진 어떤 를 만들어놨어 있는 식이 리눅스가 그래서 저 파이프랑 파이브를 오늘 배울 건데요.
이 그림 보시면 프로세스가 파이프 딱 봐도 이름도 통로잖아요.
통로 그리고 데이터를 보내고 받을 수 있는 통로입니다.
저 파이프를 연결해 줘서 데이터를 주고받는 아주 옛날 방식이에요.
일단 인터 프로세스 커뮤니케이션을 좀 정의를 하고 봅시다.
뭐라고 나와 있냐면 2 모 프라세시즈가 보통 같이 일한다.
같이 하나의 일을 수행하기 위해 보통 같이 일한다.
그래서 시그널을 통해서도 통신을 했어요. 사실 바로 전까지 배웠던 시그널도 통신이죠.
프로세스끼리 뭔가 정보를 주고받았으니까 통신인데 뭘 주고받았죠? 시그에노 상수 하나 주고받았죠 굉장히 아주 적은 피소 인플메이션만 주고받았습니다.
근데 그게 아니고 뭔가 좀 많이 주고받고 싶으면 그런 식으로 단발성의 통신이 아니고

참석자 1 07:05
진짜로 데이터를 주 주고 주목받는 스트리밍 형식의 뭔가가 필요하겠죠 그래서 처음 나왔던 리눅스가 개발되고 나서 프로세스끼리 데이터를 주고받을 수 있도록 처음 구현했던 가장 오래된 통신 방법이 파이프예요.
파이프가 정말 정말 아주 초창기에 이런 때 말이죠.
그리고 그 뒤에 순서를 좀 정해줘가지고 좀 이렇게 먼저 들어가는 애가 먼저 반드시 나가도록 순서를 정해준 게 파이버고요.
그 둘을 배우겠다라는 내용입니다. 그래서 파이프부터 봅시다.
당연히 시스템 콜이 있고요. 우리 지금 시스템 콜드를 배우는 거니까 여지껏 이미 써왔었어.
그러니까 이거 뭐예요? 테스트 해놓고 다 해놓고 wc 마이너스 l 하면 어떻게 되죠? 두 실행어가 동시에 실행이 됩니다.
엄밀히 말하면 동시에는 아니고 이게 사실은 밑에 세 줄이랑 똑같아요.
밑에 세 줄이 뭐냐면 테스트를 캡해서 템프라는 파일에다가 넣고요.
그다음에 템프 안에 있는 내용을 wc 해가지고

참석자 1 08:23
출력하고 테스크라는 파일을 지웁니다. 저 위에 거랑 밑에 거랑 완전히 동일해요.
근데 일단 wc 모르는 사람 있을까 봐 월드카운트예요.
텍스트 있으면은 단어 몇 개 있는지 세우는 굉장히 간단한 코멘드고요.
캣은 뭐예요? 캣 파일 내용을 스탠다드 아웃풋에다가 출력하는 거예요.
그래서 파일 내용 모니터에 이렇게 이렇게 쓰는 거예요.
그냥 테스트라는 파일이 있으면 그거 파일을 캡한 다음에 이 가운데 이거 있어서 월드 카운트 즉 파일 안에 단어가 몇 개 들어가 있는지 출력하는 방법입니다.
근데 지금 방법 저렇게 하면 어떻게 되냐면 이를 이를 해.
스탠다드 인에서 캣 테스트라고 하는 명령어가 받아졌으니까.
그래서 얘를 실행하고요. 그럼 얘 실행된 값이 파이프에 라잇이 됩니다.
여기에 라잇이 돼요. 그리고 그 파이프 안에 있는 애가 얘 인풋으로 들어가서 월드카운트는 캣 테스트의 아웃풋에다 대놓고 실행이 되고요.
아웃풋은 스탠다드 아웃풋으로 나갑니다. 원래 이 파이프랑 wc가 없었다면

참석자 1 09:43
이쪽이 파이프 라잇이 아니라 스탠다드 아웃풋이었겠죠 그래서 우리 모니터에 테스트의 내용이 주륵 떴을 거예요.
근데 지금 파이프 붙여놓고 다른 명령을 실행했기 때문에 파이프를 통해서 이렇게 이렇게 전달이 된 거예요.
값이. 이게 왜 이터 프로세스 커뮤니케이션인가요? 쉐 배울 때 우리 뭐 했죠? 쉐 어떻게 션 한다고 그랬어 명령어 폴크에서 새로운 차이즈 하나 만들고 걔가 execd 같은 거 사용해가지고 명령을 실행한다고 했죠 원래 페어트 남아 있고 즉 테스트를 하면 그 명령어를 실행하기 위한 프로세스가 따로 생길 거고요.
wc도 걔를 실행하기 위한 프로세스가 따로 생깁니다.
그리고 지금 우리는 그 다른 프로세스끼리 데이터를 주고받았어요.
텍스트 파일 안에 있는 내용물을 읽어다가 다른 프로세스 wc를 실행하기 위한 프로세스한테 던져줬고요.
걔는 그걸 읽어다가 단어 숫자를 셌어요. 통신한 거죠.
그래서 지금 파이프를 사용한 겁니다. 근데 지금 이분은 파이프를 어떻게 썼냐면 쉐에서

참석자 1 10:55
쉐에서 커맨드 라인에서 썼죠 근데 지금 정확하게 말하면 무슨 일이 벌어진 거냐면 우리는 지금 쉐한테 명령어를 준 거예요.
쉘한테 명령어 2개를 던져주고 사이에 파이프를 연결했습니다.
그러면 사실 이건 진짜 파이프가 아니고 파이프를 하라라고 명령을 한 거예요.
셀한테 쉐리 안에서 이거 파이팅해가지고 첫 번째 거 명령어에 두 번째 거 명령어에 가운데 파이프가 있네 해석해서 파이프 시스템 콜을 스스로 사용해서 데이터 통신한 거예요.
그래서 우리는 커맨드 라인에서 첼한테 파이프를 써라라고 해줄 수 있는 방법이 이거고요.
이거 말고 시스템 코르 밸런스 시스템 콜은 뭐냐면 아까 했듯이 우리가 스스로 우리 프로그램 안에서 쓰는 거예요.
이름 파이프죠 그리고 파리 디스크립터 2개가 있습니다.
제가 조금 헷갈려요. 잘 봐야 돼. 오래 헷갈리는데 0번이랑 1번 2개가 있어요.
근데 하나가 아마 인풋이 하나 아웃풋일 거야. 봅시다.
파이 디스콥터 0번은 리드용이고요.

참석자 1 12:05
1번은 라인 용입니다. 정해져 있어요. 이 상수예요.
첫 번째 게 리드 두 번째 게 라인. 그래서 만약에 파이프가 정상적으로 생겼으면 두 프로세스들은 0번에다가 0번 디스크립트는 내가 읽을 때 쓰고 1번은 보낼 때 써야 돼.
파이4가 기본적으로 동작하는 파이4처럼 동작해요.
뒤에 파이퍼 따로 있다라고 했죠 그거 일단 무시하시고요.
파이프도 기본적으로 먼저 들어왔으면 먼저 나와야 돼.
그냥 그 통로라고 생각하시면 돼요. 그리고 파이프는 lc이 동작하지 않습니다.
l식은 뭐였죠? 하이 포인터를 움직인 애였죠 여기서부터 읽고 싶어요.
아주 찾아다니는 상태였잖아요. 그거 동작 안 합니다.
파이프 헤더 레시 때면 에러가 나요. 그리고 파이프는 에러가 언제 나냐면 맥스 오픈 마이너스 2개보다 디스크립터가 많이 있을 때 즉 파일을 너무 많이 열어놨으면 파이프 실패할 수 있습니다.
파이프 아니 파이프

참석자 1 13:12
이거는 보기 힘들겠죠 파일을 얼마나 많이 열어놨으면 파이 디스크에 없겠어 그리고 파일도 있어요.
파일 이제 이거는 디스크릭터 개수고 이거는 시스템에 맥시멈으로 넘어갔을 텐데 둘 다 현재는 거의 볼 일은 없는데요.
옛날에는 이런 문제가 있어서 저렇게 에러를 정의를 해놨어요.
파이프도 파일이에요. 파이프도 그러니까 리눅스상에서는 모든 게 파일이라고 그랬죠 그래서 파이프도 파일로 인식이 되니까 파일 디스크립터를 주죠.
리턴하는 거예요. 파일 디스크립터 c 언어랑 연관 있는 내용인데요.
파일 디스크립터 지금 리턴하는 거예요. 리턴하는 건데 포인터가 아니고 그냥 냅둬주자.
이렇게 할 수 있는 이유가 뭘까? 원래 데이터 주려면 아이큐먼트에 있는 거 저렇게 주면 한번 리턴하는 순간 없어지지 않나요? 저렇게 줘도 되는 이유는 파일 디스크립터의 넘버만 알면 돼서 그래요.
그 안에 있는 값만 받아오면

참석자 1 14:19
값만 딴 데다 저장해 놓으면 되죠. 그래서 저렇게 포인트 안 쓰고 저렇게 그냥 값을 바로 줄 수 있습니다.
디스크립터 안에 뭐가 들어가서? 그렇죠. 상수 들어가요.
상수. 연봉부터 해가지고 원 네너티브의 리테자가 들어가기 때문에 그 값만 알고 있으면 사실 저 단수 직접 쓰는 게 아니라 내 상수 써도 돼요.
파이프의 특성을 좀 알아야 돼요. 얘가 아주 초창기에 생긴 커뮤니케이션 방법이라서 좀 특이해요.
특성이 있어요. 약간 직관적이지 못한 특성들이 몇 개 있어서 봐야 됩니다.
일단 프로세스가 파이프를 만들어서 파일 디스크립터 2개를 받았어요.
그럼 일단 통로는 연결이 됐다고 보고 거기다 대놓고 리드를 할 때 즉 0번 디스크립터에다가 라이스를 하면 되겠죠 라이즈는 이제 리드를 하면 되겠죠 리드를 하면 되겠죠 고 0번 디스크립터에다가 리드를 할 때 만약에 아무도 그 파이프에다 써놓은 게 없다면 바로 리턴합니다.
당연하죠. 이거는

참석자 1 15:24
내가 파이프 안에서 읽으려고 했는데 들어가 있는 데이터가 없어.
바로 리턴입니다. 그리고 파이프가 아니지 반대 안 비어 있을 때 데이터가 있으면 바로 읽어와요.
근데 비어 있으면 블라킹입니다. 블라킹. 비어 있으면 누군가 쓸 때까지 기다려요.
리턴은 안 돼요. 이게 이게 특이한 문제가 덜 직관적이라는 얘기인데 데이터가 들어가 있었으면 그냥 그걸 싹 빼우고 리턴을 하니까 해피한데 아무도 안 썼어.
그 상식선에서는 아무도 없네 데이터 없네 이러고 그냥 리턴 하면 좋은데 리드를 보는 순간 파이프가 비어 있으면 파이프에 누군가 쓸 때까지 계속 밸런싱이 되고 그래서 저 프로세스는 계속 홀드 돼 있어요.
뒤로 못 넘어가고 리드가 리턴을 안 하고 있습니다.
그래서 다른 프로세스가 누군가가 거기다가 와잇을 해줘야 돼요.
그 순간 데이터 받아서 리턴을 합니다. 위험한 구조죠.
코딩이 잘못하면

참석자 1 16:27
내가 리더라고 들어놨는데 아무도 라잇을 안 하고 다 다 프로세스가 리턴해버렸어요.
그러면 드라이 저도 혼자서도 데드락이 될 수 있어요.
두 번째 라잇을 하고 싶을 때 파이프가 꽉 차 있지 않으면 즉 내가 라이트 할 수 있는 공간이 있으면 바로 리턴을 합니다.
그냥 쓰고 리턴하면 되니까 반대로 꽉 차 있으면 또 얘도 기다려.
하이퍼에 빈 공간이 있으면 누군가가 파이프에 있는 걸 읽어가서 빈 공간이 생길 때까지 라잇이 리턴을 하지 않고 기다립니다.
그래서 누군가가 만약에 타이머가 꽉 차 있는데 리드라는 애가 죽었거나 이러면 얘도 데드락이 될 수 있어요.
그래서 이게 이제 기본 특성이고요. 원래 슬라이드 이렇게 주부를 많이 쓰면 안 되는데 방법이 없어서 써놨어요.
만약에 라이스를 위한 파일 디스크립터가 클로즈 되면 어떻게 될까? 클로즈할 때 이제 두 가지 경우가 있죠.
하나는

참석자 1 17:42
파이프가 1대 1 통신이 아니에요. 지금 그림은 마치 1대 1 통신처럼 해놨는데 파이프를 여러 프로세스들이 쓸 수 있습니다.
근데 내가 라이하던 디스크립터를 닫았어요. 클로즈로.
근데 다른 놈이 또 라잇을 할 수 있는 상태라면 아무 일이 발생하지 않아요.
근데 내가 마지막 프로세스였어. 라이트 할 수 라이팅 디스크립터를 갖고 있었던 마지막 프로세스였는데 내가 그걸 닫아버리면 리드 하려 했죠.
리드하려고 걸려 있었던 분들이 바로 에이터 라이트 합니다.
왜냐면 내가 마지막 라이터였기 때문에 내가 이 디스크립터를 닫는 순간 리드 때문에 블락 돼 있었던 애들이 데이터를 받을 수 있는 여지가 없어져요.
그러니까 걔네들도 바로 리턴을 해버려요. 에러 에러 내면서 무슨 에로 앤도우 파일 앤도우 파일이 파일 뒤에 데이터가 없다죠 내가 파이프에 라이팅을 할 수 있는 방법은 더 이상 없기 때문에 바로 저렇게 유턴을 해버립니다.
반대로

참석자 1 18:47
리더가 클로즈 하면 똑같아요. 그러니까 다른 리더가 있으면 아무 일 발생하지 않는데 내가 마지막 리더였으면 이거는 좀 문제가 있어요.
이건 내 생각에 위에서 내가 마지막 라이터였는데 클로즈를 해버렸으면 그냥 리드 못하고 끝나요.
그러니까 의도를 했건 안 했건 좀 좋은 상황은 아니지만 그냥 내가 리드만 안 하면 끝나는 거죠.
라이트 아래가 없으니까. 근데 반대로 라잇을 누가 해놨는데 리더가 없어졌어.
라이스를 해놨는데 리드가 없어졌으면 데이터 날아간 거잖아요.
통신을 하려고 그랬는데 못 받았어. 그러니까 걔는 시그널 처리를 합니다.
시그 파이프라는 시그널이 발생을 해요. 시그 파이프가 이럴 때 발생을 합니다.
시그 파이프 핸들링은 보통은 데이터 없어졌어라고 출력하고 그냥 끝내거나 아니면 스파이프 다시 만들어가지고 데이터 받아가야 돼.
다시 보내줘라고 요청해야 되겠죠 그런 내용이고요.
예제 있습니다. 이거는

참석자 1 19:57
당연히 내일 우리 실습은 파이플 실습을 해볼 거고요.
아주 간단한 코드니까 봅시다. 메시지 사이즈가 16개래요.
그리고 메시지가 헬리월드 1 2 3 3개가 정해져 있고 상수로 메인 함수가 16개짜리 캐릭터 인 버프를 만들어놓고 시작합니다.
파이프를 만들었어요. 파이프를 실행할 때 어떻게 실행하는지 보세요.
인테자 배열 2개짜리 넣어주죠 그럼 여기다가 디스크립터 2개를 넣으실 거예요.
발수가 정상적으로 리턴했으면 그 첫 번째는 리드용 디스크립터 두 번째는 라이드용 디스크립터 받아왔겠죠 그다음에 라잇 합니다.
3개를 라이트해요. 메시지 1 2 3을 16개만큼 캐릭터를 라이트 합니다.
일단 라이스 다 끝났고요. 마이스 그때 뭐라고 그랬죠? 공간만 있으면 바로 리턴한다고 그랬죠 블라킹이 아니에요.
이걸 왜 얘기하냐면 일반 파일 스탠다드 아이오 같은 거 할 때 리드 라이스 뭐였어요? 블랙킹 함수였어요.
그래서 항상 블랙킹이 됩니다.

참석자 1 21:10
정상적으로 수행할 때까지 근데 파이프는 아닐 때가 있다라고 했죠 그래서 지금 그 얘기를 한 거였고요.
일단 여기서는 라잇을 세 번 하고요. 골문 3개 돌면서 리드를 합니다.
근데 라이 1번에다 했고 리드는 2번에 나오죠 그러면 내가 쓴 거 내가 다시 읽어본 거예요.
이거 세 번 쓰고 세 번 읽습니다. 여기 프린트 하우 아무 의미없는 내용인데 그냥 파이프 어떻게 쓰는지 보여주는 아주 간단한 코드예요.
그래서 이렇게 그림이 1번에다가 대놓고 라이트 세 번 하고 0번에서 내가 쓴 거 내가 읽고 이렇게 되고요.
이거는 멀티 프로세싱에서 실제로 쓰는 방법이에요.
봅시다. 똑같이 16바이트짜리 버퍼를 만들어놓고 메시지 3개 정의해놓고 파이프를 엽니다.
파이프가 0번 1번 유디용 라인용 생겼어요. 그리고 바로 폴크를 부릅니다.
프로세스가 두 개가 뿅 됐습니다. 폴크 공부하셨으면 기억하실 텐데 하이디스크립터 복사해갑니다.
그래서

참석자 1 22:23
파이프를 열어놓은 상태에서 보크를 누르면 우리 파이프가 연결이 된 거예요.
서로 파이프를 갖고 있으니까 그러면 pid가 0이면 차일드죠 아니면 트 차일드는 라이트고요.
페런트는 이니 그래서 요 3개 3개 하는데 이거는 이제 멀티 프로세싱 환경에서 한 놈은 쓰고 한 놈은 있는 예제고요.
아까랑 동일하게 동작을 할 거예요. 그리고 여기 지금 뭐라고 써 있죠? 만약에 페어런트가 세 번보다 더 읽으면 어떻게 될까? 라이트한 놈이 없죠 그러니까 기다립니다.
누락됩니다. 누군가 라이트 할 때까지 기다리고 있을 거예요.
그래서 파이프가 이제 좀 쓰기가 까다로운 게 뭐냐면 멀티 프로세싱인데도 불구하고 페어가 딱 맞아야 돼요.
페어가 딱 안 맞으면 맞는 놈이 기다려 라이스를 했는데 받는 놈이 없어지면 라이턴에서 리턴하러 기다릴 거고 아니지 라이스 그냥 리턴하죠.
헷갈린다. 자고 공부하세요. 이게 파이프가 옛날 거라고 그러는 이유가 딱 봐도 지금

참석자 1 23:41
헷갈리잖아요. 사용자 편의가 이렇게 뭔가 이렇게 고려되지 않아요.
색이 되게 힘들 그게 옛날 거랑 딱 느낌이고요. 요즘 나온 걸수록 소프트웨어들의 패턴이 그러니까 이게 경향이 사용자가 사기 어떻게 하면 사용자가 쉽게 사용할까를 고려를 해서 소프트웨어를 짭니다.
그게 안 돼 있어요. 지금 파이하 잘 지금 본 예제가 이거예요.
굉장히 이게 실수를 하기 쉽게 생긴 구조인데 같은 1번에다 대놓고 둘 다 마이스 할 수가 있습니다.
페널티도 많이 탈 수 있고요. 차기도 마이스 탈 수 있습니다.
그리고 이 것도 자기도 읽을 수 있고 사유도 읽을 수 있어요.
그러면 지금 만약에 나서 했다고 합시다. 둘 다 라이즈를 했어요.
그러면 둘 다 리드를 그다음에 해봅시다. 뭘 누가 가져갈까 이게 컨트롤이 돼요.
예를 들어서 차일드는 0번은 0을 쓰고 펠런트는 1을 씁니다.
내 동지

참석자 1 24:49
지금 프로세스 둘이니까 완전히 독립적으로 돌아가죠.
그다음에 얘도 리드를 하고 얘도 리드를 했어. 그럼 누가 0을 가져가고 누가 1을 가져왔는지 알 수 있어요? 없어요 그거는 누가 먼저 라이스 했느냐의 차이고 또 누가 먼저 리드를 했느냐의 차이기 때문에 디터미니스틱하지 않고 운영체제가 스케줄링을 어떻게 했느냐에 따라서 바뀔 수 있습니다.
순서가. 그래서 파이프는 다른 통신들과 다르게 싱크로나이제이션을 보장하지 않아요.
내가 해야 될 거야. 유저가 해야 돼. 그래서 원시적인 타입의 커뮤니케이션이라고 불러요.
여기 또 다른 예제가 하나 있는데 얘는 뭐가 더 있는지 봅시다.
똑같이 메시지 16개짜리 버터에다가 3개 해놓고 파이프 만들어놓고 폴크를 했어요.
코드 아까랑 똑같은데 이 클로즈 생겼어. 클로즈 이게 뭘 한 거예요? 잘 생각해 보세요.
차일드는 와인만 하죠. 리드 디스크립터가 필요 없죠 그래서 라이트 하기 전에 리드 디스크립터를 달아놓습니다.
그리고 반대로 페먼트는

참석자 1 26:03
나는 윌드만 할 거니까 라인용 데스크에서 를 닫아버려요.
클로즈 그리고 아까랑 똑같이 동작을 해요. 그러면 사실은 프린트는 똑같이 될 건데 파이프가 이렇게 바뀐 거죠.
아까 그 h자형 통로였던 게 이렇게 통로가 바뀌었어요.
이게 이게 맞는 사용법이겠죠 이렇게 하면 나중에 혹시나 내가 리드 라이즈를 실수를 해서 저렇게 동시에 한다거나 이런 여기는 아예 없어져요.
그래서 파이프 사용할 때는 이렇게 안 쓰는 걸 먼저 닫아야 돼요.
쓰기 전에 사용하기 전에 안 쓰는 디스크립터들은 닫아야 돼요.
파이프에 제약 사항들이 몇 개 있으니까 한번 봅시다.
파이퍼 버프라고 하는 상수가 저 리미트 점 헤더에 정의가 돼 있어요.
저 리니츠 점 헤더 가서 보면 바벨드 오만 리미트가 다 저기 들어가 있어요.
그래서 한번 볼 수 있어요. 이렇게 지원이 있구나.
그러고 이제 파이프에 맥시멈이 있는데 파직스 스펙이랑 리눅스 스펙이 좀 달라요.
파직스는 약간 좀 보수적이에요. 적어도 저만큼은

참석자 1 27:21
지원을 해줘라라고 하는 애들이기 때문에 512바이트까지만 있으면 파이프 지원하는 거야라고 정의를 해놓은 거고요.
리눅스는 당연히 파직스 컴플라이언트 소프트웨어입니다.
파직스의 규칙을 잘 따른 소프트웨어인데 얘보다 크죠 크니까 컴플라이언트 한 거예요.
만약에 리눅스가 66바이트밖에 파이프를 지원을 안 한다 그러면 파직스 소프트웨어라고 부를 수가 없겠죠 파직스를 따르지 않았으니까 지금 4k예요.
보통 리눅스는 4k까지 파이프를 지원을 하니까 저기 사케가 뭐죠? 페이지 페이지 사이즈 페이지 하나 사이즈로 맞춰놨습니다.
보통 파이플은 그렇게 해요. 그래서 페이지 하나씩 플로우 라이트 할 수 있는 사이즈를 줍니다.
파이프 토털 사이즈는 뭐냐면 파이프들을 여러 개 동시에 열 수 있겠죠 근데 리눅스에서는 저렇게 64메가까지만 64k까지만 허용을 합니다.
이것만 봐도 파이프가 얼마나 옛날 거라는 걸 알 수 있죠 통신인데 64k가 토털 사이즈예요.
리눅스 통틀어서

참석자 1 28:31
하나의 파이프는 4k 이상 안 되고 4k 넘어가는 거는 파이프를 못 쓴다는 소리예요.
내가 데이터를 통신을 하고 싶은데 내가 보낼 데이터가 4kg가 넘어가면 파이프 못 써요.
쓰려면 잘라서 보내야 되겠죠 파이프가 꽉 찼을 때 블락이 됩니다.
라이스를 더 이상 할 수 없게 라이터가 블락이 되고요.
누군가가 읽어갈 때까지 기다려야 돼요. 아까 얘기했던 데이터 컨시스턴시 문제가 있을 수 있어요.
그래서 버퍼를 누군가가 동시에 리드하고 라이트 할 수 없도록 필요 없는 애들은 닫아줘야 된다.
그리고 여기 지금 라이 리퀘스트가 파이프 버프보다 크면 파이프 버프가 저기 정해져 있는 상수 저거보다 크면 여기 파란색을 뭐라고 써 있어요 파이프 버프만큼만 라잇이 되고요.
그다음 데이터는 알아서 나눠서 써지긴 해요. 그건 이제 라이트 파이프가 아니라 리눅스의 라이트 함수가 그렇게 똑똑하게 구현을 해놓은 건데 그게 사실 똑똑한 게 아니고요.

참석자 1 29:40
예를 들어서 두 프로세스가 동시에 라이즈를 합니다.
근데 둘 다 4k바이트가 넘게 라이스를 해요. 예를 들어 8,192 페이지 2개짜리 라잇을 둘이 동시에 한다고 해봅시다.
그러면 라이트 함수는 4케이스 잘라서 두 번의 라잇을 하겠죠 근데 원래대로 한 번에 넣을 수 있었으면 한 놈이 파이프 8k 자리에 넣고 그다음 에가 라이스 해서 데이터가 정상적으로 딱 끊어질 텐데 4k씩 나눠서 하겠죠 그래서 순서가 바뀔 수 있어.
순서가 바뀔 수 있기 때문에 라잇을 두 번 알아서 쪼개서 해주는 대신에 순서는 고장 안 한다.
이게 파이퍼의 한계점입니다. 저거는 답이 없어요.
그건 수행할 수 있는 방법은 유일하게 수행할 수 있는 방법은 둘이 동시에 가지 안 할 수 있겠죠 여기 예제가 있는데요.
얘들도 한번 봅시다. 그러면 메인 함수고요. 함수 하나 원한이 있는데 저 뒤에 있네요.
그냥 프린트 해주는 애예요. 프린트프 찍어주는 애고 시그 핸들러를 달아주네요.

참석자 1 30:51
이거는 알람이니까 그냥 시그널 발생하면 모아왔다라고 프린트해 준 시그널일 거고요.
파이프 열고 파이프 열고 나서 시그 액션 등록해주고요.
알람이라는 시그널에다가 요거 등록해 준 거예요.
여기도 등록해줬고 저거 지금 에프티스 컴퓨터에 뭐 하는 수인지 아마 써놨을 건데

참석자 1 31:22
저 f 패스트 컴프도 시스템 콜인데 저 뒤에 있는 저 옵션을 주면 파이프 버프 그 상수 있죠 맥시멈 사이즈 파이프의 맥시멈 사이즈를 리턴해주는 시스템 콜이에요.
별로 중요한 내용 아니고 저거 저렇게 부르면 하이프 사이즈 받아올 수 있죠 그래서 맥시멈 사이즈 요거다라고 프린트 해주고 넘어가고요.
와이을 돌면서 알람 20초 부르고 알람 부은 거예요.
20초 있다. 나한테 스스로 시그널 그리고 와이스를 합니다.
알람이 없. 그리고 124번 뒤에 124번 계속하는 거죠.
124번 할 때마다 몇 개 캐릭터가 있다라고 프린트하는 거죠.
이게 뭐냐면 파이프 버퍼가 몇 kg인지 일단 알아내고요.
그다음에 계속 넘칠 때까지 라잇을 해보는 거예요.
그다음부터 어떻게 될까 보이겠죠 원바이트씩 하는 거니까 저기 20이 아마 초가 아니라 밀리세크일 거예요.
그래서 지금 20 말이 안 돼 있어. 20 밀리세크로 해서 맥시멈 사이즈 4k다라고 돼 있고 4kg 될 때까지 계속 아이스입니다.

참석자 1 32:36
그러다가 라이시 블록 됐다. 이 알람이 발생해가지고 65,536부터는 블록이 됐다라고 포인트가 되죠.
저렇게 됐고 블랙킹 덤블랙킹 얘기를 좀 해봅시다.

참석자 1 33:00
아까 잠깐 얘기했었죠 리드는 언제 블록 간다고 라이트 할 데이터가 없을 때 블록 라이즈 마이할 공간이 없을 때 블록된다고 했었죠 그리고 그렇게 블록킹이 되면 이제 이벤트 이벤트 핸들링도 그렇고 아이오도 그렇고 통신도 그렇고 블라킹 런블라킹이 둘 다 지원이 됩니다.
블라킹의 장점은 뭐죠? 블록킹은 반응 속도가 빨라요.
내가 블록 돼 있다가 동작이 가능해지는 순간 바로 수행하겠죠 넘블러킹은 내가 일단 할 수 없는 상태라는 게 디텍트가 됐으면 그리고 내가 리드를 하고 싶은데 아무도 데이터를 안 써놔서 지금 파이프가 비어 있는 상태인 걸 디텍트 했으면 런블라킹을 기다리는 게 아니라 리턴에요.
리턴에서 자기 할 일 다른 거 그냥 다음 인스트럭션 쭉 수행합니다.
그러다가 나중에 내가 리드할 게 생겼을 때 시그널 발생하고 시그널 핸들링으로 리드를 합니다.
그게 너블라킹인데요.

참석자 1 34:08
장단점이 있겠죠 당연히 기다리고 있다가 쳐다보고 있다가 내가 할 수 있는 일을 하게 되면 할 수 있게 되면 바로 하는 거랑 아니면 그냥 예약 걸어놓고 딴 데 가서 딴 일하다가 데이터 왔어 하면 가서 그때 가서 다시 가서 읽는 거랑 뭐가 더 좋은지는 상황마다 다르니까 적절한 걸 사용하면 되는데요.
넌 블라킹은 기본적으로 사용이 까다롭습니다. 사용이 어려워요.
왜냐하면 시크너나이제이션을 내가 해줘야 되니까 근데 블라킹은 아무것도 못하고 기다리고 있어서 자본이 낭비될 가능성은 있지만 적어도 싱크로나이제이션을 대상 처리해야 되지 않아요.
그냥 기다리니까 그래서 장단점이 있는데 디폴트는 블록킹입니다.
모든 io는 통신이 됐건 디스크라이어가 됐건 이벤트 시그널들링이 됐건 디폴트는 블록킹이 넌블라킹을 하고 싶으면 옵션을 줘야 돼.
이렇게 5 언더바 넌블라킹으로 해가지고 저 파일 디스크립터잖아요.
지금 바이크 쪽 파일 디스크립터 연결이 돼 있죠 거기다가 fcnt 해가지고

참석자 1 35:15
넘블러킹으로 세팅해주면 일반 파일처럼 파이프 통신도 넘블러킹으로 할 수가 있습니다.

참석자 1 35:28
혹시 질문 있어요? 여기까지

참석자 1 35:36
넌블라킹 리드랑 라이브 한번 봅시다.

참석자 1 35:47
f 스탭을 사용하는 방법이 있고요. fcntl을 사용하는 방법이 있습니다.
두 가지가 다 이제 만플랫폼으로 처리할 수가 있는데요.
첫 번째 방법은 이걸 덤블라킹이라고 해야 될까? 유저가 매뉴얼리 그렇게 하는 거예요.
내가 리드를 할 수 있는 타이밍이 됐을 때 즉 다른 할 일이 없을 때 에프스t으로 저 파이 디스크립터의 상태를 봅니다.
그래서 프스t에 보면은 파일 상태를 알려주는 거죠.
저 파일 상태를 읽어와서 st 사이즈 하면 파일 사이즈 나오잖아요.
파일 사이즈가 0보다 파이프 버프 4k보다 크면 에러 유턴하는 거고요.
그거 아니면 리드를 하겠죠. 그런 식으로 파이프 안에 데이터가 있는지 없는지 내가 매뉴얼리 보고 있을 때 리드를 하는 게 넌 블러킹이죠.
항상 들어가서 기다리고 있는 게 아니라 내가 리드할 수 있을 때마다 저 두 줄 실행시켜주면 되잖아.
그게 이제 런블라킹 공하는 첫 번째 방법이고 두 번째는

참석자 1 36:55
fcntl로 그냥 파일 속성 자체를 바꿔버리면 됩니다.
넘블라킹을 바꿔버리면 그다음부터는 그냥 아무 생각 없이 리드하면 걔가 넘블라킹이 돼요.
그래서 리드는 바로 리턴을 할 텐데 저 다음부터는 리드하면 버퍼에다가 데이터를 긁어오라는 거잖아요.
리드가 리턴했다고 해서 데이터가 버퍼에 있으면 대장이 없어야 돼.
언제 될지 몰라. 근데 리드는 리턴을 해버려요. 그래서 데이터가 실제로 올 때까지 딴 일을 합니다.
보통은. 그리고 한참 딴 일하다 가보면 데이터 들어와 있겠지 뭐.
그게 실제로 넘블라킹이에요. 예제가 있는데요.
그는 메인 함수에서 파이프를 열고요. 여기 파이프 열고 넌블러킹으로 세팅을 해줍니다.
리드용에다가 그다음에 폴 클러입니다. 기본적으로 둘 다 일단 폴 클라이에서 생긴 차이나 차이지만 리드가 넌플라킹이에요.
둘 다 0번에다 해줬으니까 그 상태에서 차일드는 차일드 시하고 파리는 차일드 시하고 먼지 뒤에 나오면

참석자 1 38:12
차일드는 왼쪽 페라드는 오른쪽을 각자 실행을 합니다.
그래서 안 쓰는 거 닫아놓고 안 쓰는 거 닫아놓고 호흡을 돌면서 차열되는 세 번을 라이스 해요.
라이스 라고요. 라이스는 블록킹이겠죠 그냥 데이터 공간 있을 거니까 그냥 바로 세 번 리턴하고 라이트 하고 리턴할 거예요.
마지막에 한 번 더 하네. 패런트는 아까 이거 라이트 한 거고 플러스 해놓고 얘 리드만 하겠다는 소리죠 리드가 아까 뭐였어요? 원블라킹이죠.
폼을 계속 돕니다. 계속 돌면서 리드를 해봐요. 리드를 해보고 리드된 바이트 리턴 맞죠 이게 마이너스 1이면 에러난 거고 0이면 제대로 읽어온 거예요.
지금 읽어온 게 아닌데 얘여야지. 얘는 아무것도 없다.
비어 있다. 언블락킹인데 비어 있다는 거고요. 뭔가 있으면 프린트를 합니다.
근데 지금 이렇게 구현할 수 있었던 이유가 얘가 넘블라킹이니까 스위치 케이스 안에서 데이터가 있었건 받았건 안 받았건 그냥 무조건 리턴을 해서 안으로 들어와요.

참석자 1 39:23
이게 넌블라킹을 사용하는 대표적인 방법인데요.
이렇게 한번 실행하고 있구나. 지금 차이드는 세 번 골문 안에서 라이트하고 마지막에 바이 리턴을 하는데요.
그는 페트는 초마다 확인을 하고 있습니다. 초마다 확인을 해서 얘는 3초에 한 번씩 라잇을 했을 거예요.
그러면 슬립 3초 하죠 3초에 한 번씩 라잇을 하고 메시지 2 바 라이트 하고 나가는 거고 얘는 슬립 1초죠 매초 확인을 합니다.
그래서 한 번 위드 했을 때는 메시지 1로 받았고 뒤에 3초 동안은 아무것도 없어서 시그널 핸들링해주다가 또 들어왔을 때 프린트 또 3초 아무것도 없고 뭔가 이제 런타임 시스템 느낌이 나죠 이렇게 둘이 한 놈은 3초에 한 번씩 라이트하고 다른 놈은 1초에 한 번씩 리드하고 근데 만약에 저게 리드가 블라킹이었으면 어떻게 됐을까? 굉장히 요 세 개가 안 찍혔겠죠 요 세 개가 안 찍히고 그냥 요거 4초에 한 번씩 찍히고 끝냈을 거예요.
그게 저기 가서 이게 만약에 블랙행이었다면

참석자 1 40:47
여기서 리턴을 안 하고 계속 기다리고 있었겠죠 데이터 들어올 때까지 즉 요구가 중간에 시행이 안 됐을 거예요.
이렇게 구조를 하는 이유가 사실은 뭘까? 이 세 칸 멍청하게 찍으면 되지 딴 일 할 수 있잖아.
내가 딴 일을 하고 와서 3초에 한 번씩 확인하면 되겠죠 넘블라킹을 사용하면 보통 그런 이유로 합니다.
항상 바로바로 뭔가 데이터를 받아야 되는 경우가 아니라면 엔블라킹을 사용하면 좀 더 효율적으로 자원을 활용할 수 있다.
여기 이제 셀렉트라는 시스템 콜이 하나 나옵니다.
여기 이제 통신을 하는 방법인데 사실 셀렉트는 저기서 파이프 때문에 쓰는 용도는 아니고 원래 이제 진짜로 소개 프로그래밍할 때 쓰는 용도인데 사이트가 뭐냐면 파일 디스크립터 여러 개를 모니터링하는 함수예요.
파일 디스크립터 여러 개를 등록을 해놓으면 셀렉트는 그 파일 디스크립터 중에 뭐가 들어왔는지 안 들어왔는지 그러니까 데이터가 들어왔는지 안 들어왔는지를 모니터링해 주는 함수입니다.
그래서 지금 보면

참석자 1 42:04
라이트 한 애가 둘이 있죠 여기 지금 두 프로세스가 독립적으로 라잇을 할 거고요.
반나에는 한 동이에요. 대신 디스크립트 파이프가 통로가 따로 있죠 키하고 q하고요.
통로가 2개 있고 걔는 리드를 두 개를 할 거예요. 근데 만약에 내가 셀렉트 없이 그냥 구현을 하면 어떻게 될까? 만약에 블라킹 함수를 썼다면 첫 번째 첫 번째 리브가 블링 파이프에 데이터가 들어올 때까지 패런트는 블라킹 돼 있겠죠 그래서 아무것도 모르고 기다릴 거예요.
그러다가 첫 번째 거 들어오면 그제서야 두 번째 파이프를 리드를 합니다.
그 사이에 차일드 프로세스가 라잇을 계속해놨으면 데이터가 쌓여 있겠죠 셀렉트가 있으면 셀렉터도 기본적으로 블라킹하고 줄 건데 등록해 놓은 디스크립터들 중에 누군가가 데이터를 마이스를 하면 바로 유턴을 합니다.
그래서 걔를 먼저 처리할 수 있게 해줘요. 여러 개의 디스크립터들을 모니터링할 수 있게 해준다.
그래서 그중에 순서 상관없이

참석자 1 43:12
하나 이상의 디스크립터가 리드할 데이터가 생긴다거나 라이트할 공간이 생긴다거나 하면 바로 리턴을 해줘요.
이렇게 타임아웃이 있어서 타임아웃 기능이 있어서 몇 초 이상 아무것도 없으면 다르게 동작을 시킬 수도 있어요.
근데 그거는 벤스트 피처니까 보면 될 것 같고 셀렉트 지금 이제 리드랑 라이즈랑 익셉트 fds라고 그래가지고 3개를 등록을 할 수 있습 이게 리드 와이 익셉트죠 그래가지고 각각이 포인터 여기 보면 포인터라는 게 여러 개씩 줄 수 있다는 소리죠.
그래서 파일 디스크립터 x니까 파일 디스크립터 여러 개를 여기다 주고 얘도 파일 디스크립터 여러 개를 여기다 적을 건데 리드용 라인이요 익셉트는 우리 안 배웠는데요.
익셉트는 몰라도 돼요 안 써요 그러니까 약간 옛날 기능인데 남아 있는 기능이라고 생각하시면 되고요.
리드 가기만 하시면 됩니다. 파이프도 옛날 건데 파이프의 아로스테이팅이면 몰라도 돼요.

참석자 1 44:23
그래서 리드용 파일 디스크립터 3개 라인용 3개 익셉터 3개 해가지고 저 셀렉트를 걸어놓을 수 있고요.
그중에 마스킹도 할 수 있습니다. 여러 개 주는데 나 그중에 다 보는 건 아니고 연어들은 안 볼 거야 하고 마스크를 벗을 수 있어요.
저 밑에 있는 한 줄 써가지고 마스크 벗으면 되고요.
이제 예를 들어보면

참석자 1 44:48
파일 디스크 두 개 만들어놓고 리지스 만들어놓고 파일 두개를 엽니다.
파일 2개를 열어서 리드 셋 그러니까 이 셋에다가 일단 다 0 처리해놓고 1이랑 2 얘네 둘만 플래트를 그러면 셀렉트 부를 때 얘네 둘 보겠다는 소리죠 얘네 둘을 보는데 그중에 누군가가 리론이잖아요.
리드 데이터가 생겼을 때 바로 알려준다.

참석자 1 45:20
지금 보면 또 다른 보실 때

참석자 1 45:30
세넥트를 좀 다르게 쓰는 방법이에요. 지금. 얘는 2차원 배열인데 3개짜리 2개죠 아니지 두 개짜리가 3개씩 두개짜리가 3개예요.
그래서 홈은 세 번 돌면서 파이프를 3개를 열어줄 거예요.
파이프를 3개를 열어주는데 이 셋이겠죠 그러니까 저렇게 통로가 3개가 열립니다.
3개가 열리고 폴크를 불러요. 그 차이드랑 페먼트 생겼죠 그 상황에서 차트는 차트 부르고 패런티는 페런트 부르고 이거 왜 이렇게 가지 공간이 없어서 이렇게 가.
그래서 통로 지금 3개 만들어놓고 폴은 돌면서 폴크를 계속 불렀으니까 차일지 셋이 생긴 거예요.
지금. 그래서 각자 자기 통로를 가지게 됐습니다.
그다음 페럴린트는 뭐예요? 통로가 3개 있으니까 얘는 리드 할 때 어떤 놈이 라이스 했는지를 모니터링을 해줘야 되겠죠 그러면 여기 지금 포문 3개 돌면서 각자 0번 1번 2번에 대한 플래그를 세워줍니다.
그리고 솔로트를 불러 셀렉트 불러서 와 원을 돌면 이중에서 뭔가 라이트 할 때 들어오는 놈을 바로 받아와서

참석자 1 46:46
리드에서 이 채널이 지금 5초 채널 채널에 있는 디스크립터를 리드하면 플리트 할 수 있고요.
그거 쭉 계속하는 거예요. 와만 안에서 계속하는 거고요.
이거는 지금 리드가 뭘까?

참석자 1 47:03
이거는 이제 0번이네요. 우리가 열어놓은 파이프가 아니에요.
얘는 리즈 셋이니까 셋에 0번이 있으면 스탠다드 인풋 그러니까 유저 인풋이 들어왔다 라고 뿌려주는 거고요.
뒤에 4분이 진짜 크레이프 통신이에요. 그래가지고 우리가 알고 있는 요 여러분 3개의 통로 중에 하나가 셋 돼 있었으면 걔한테서 읽어라.
최대한 간단하죠 그냥 돌면서 읽어주는 거야. 자기 거에다가 자기가 받아온 라이브 채널에다가 그냥 메시지 찍어줘요.
그러면 실행하면 이렇게 됩니다. 메시지가 0번이 보냈고 서버 오패런트가 출력 1번이 보냈고 출력 2번이 보냈고 출력.
그리고 내가 만약에 d라고 d 엔터 해가지고 유저 인풋을 보내면 아까 여기 요 인풋 요거 요거 요거 셀렉트가 셀렉트가 보고 있다가 그 파이터는 아닌데 다른 애가 인풋이 들어왔어 지고 스탠다드 인풋 들어왔어라고 해주는 거고요.
그리고 또 가만히 있으면 차일드가 계속 보낼 겁니다.
세 번 보내겠죠 요 예제가 조금 복잡한데 셀렉트 완전히 이해하려면 요 예제는

참석자 1 48:14
이해하고 가야 돼요. 우리 저거 내일 실습 시간에 아마 해볼 거니까 그거 해보시면 좀 더 이해가 머릿속에 더 잘 남을 거예요.
이제 조인인데 조인이 뭐냐면 오케이. 이게 마지막 기능이에요.

참석자 1 48:35
페런트 프로세스가 있습니다. 페런트 프로세스가 있고 통신을 페런트랑 샤이드랑 하는 게 아니고 이 것처럼 차일드가 포크를 아니에요.
그리고 두 놈이 통신을 한다고 합시다. 샤일드랑 그래픽 차일드랑 통신을 이렇게

참석자 1 49:11
봅시다. 한둘씩 조인 함수가 뭐 하는지 봅시다. 일단 볼크를 해요.
볼크를 해서 클라이언트는 웨잇을 합니다. 아무것도 안 하고 그냥 웨이 해요.
그럼 이제 샤이드가 차일드가 뭔가 하겠죠 차일드가 여기로 넘어가가지고 파이프를 만들고요.
포크를 다시 부릅니다. 아까 그림처럼 차일드가 다시 만들었으니까 차일드 그대로 있고 그랜드 차이도 생겼겠죠 그래가지고 얘네 둘이 얘는 차일드 그러니까 그렌지 차이드죠 얘가 그렌지 차일드가 주도하에 파이프를 디핑킹터입니다.
어디다가? 1번에다가 스탠다드 아웃풋에다가 즉 파이프 통신이 스탠다드 아웃풋을 오브라이트 한 거예요.
그 상황에서 다 클로즈 하고요. 그다음에 대국적이다.
이거 컴 1이 뭐예요 받았네. 뭐 받았는지 봅시다.
여기 있다. 여기 있다. 조인 함수를 실행하는 애가 지금 메인 함수가 여기 있는데요.
원하고 2를 주죠. 원이 뭐냐면 ls 마이너스의 경로 2는 그랩

참석자 1 50:25
근데 이 ls 마이너스 l 경로를 받아가지고 exec 합니다.
그냥 바꿔치기 하는 거죠. exec니까 그랜드 차일드가 ls 마이너스 l 할 거고요.
저 그냥 차일드가 저거 할 거예요. 브랙 할 거예요.
그래서 이게 시간이 어떻게 되냐면 뒤에 네 슬로테이션 때 있는데 ls 마이너스 l 하면 아웃풋이 있겠죠 그 아웃풋이 어디로 가요? 원 실행하는 애가 얘니까 디플리케이트했기 때문에 파이페 와 되는 애가 스탠덜드 아웃풋을 오브라이 했어요.
즉 제 ls의 아웃풋 쭉 화면에 출력돼야 될 애가 1번 대신에 파이프 들어옵니다.
즉 파이프에 ls의 결과물이 들어가요. 그러면 쟤는 차이드는 그린티 차이드가 ls를 실행하는 동안 파이프에서 받아서 스탠다드 인풋이 파이프가 돼버렸죠.
저희 케이트 해가지고 그래서 lf 출력값이 파이프로 들어가서 얘는 파이프로 받습니다.
그거를 그 가지고 처리하는 거야. 그랩은 뭐죠? 찾는 걸 찾는 거 그 안에서 이제 특정 키워드를 찾는 건데

참석자 1 51:55
lx 안에서 뭔가 특정 키워드를 찾는 건데 그거를 이게 그거 한 거예요.
커맨드 라인에서 아까 처음에 봤었던 거 이렇게 바 해가지고 파이프 해가지고 커맨드 라인 통해 커맨드 라인에서 파이프 산 보고 구현한 거예요.
그래가지고 이거는 좀 차근차근 읽어보시고요. 이거는 교과서에 가면 코드 풀도 있고요.
설명이 좀 더 있으니까 그것도 읽어보세요. 이거는 별로 어려운 내용은 아닌데 지금 설명이 너무 여기 없어가지고 코드 그림밖에 없어서 좀 이해하기 어려울 수 있는데 코드 천천히 읽어보면 이해가 될 거예요.
여기까지 해서 파이프는 끝났고요. 파이프 지금 이거 있어요.

참석자 1 52:49
질문 없으면 파이프 끝냅시다. 몇 장 안 돼요. 파이프.
이거는 특수한 기능이 추가된 파이프예요. 파이프.
파이프도 기본적으로 파이프도 파이퍼처럼 동작은 하지만 여러 개가 있을 때 즉 멀티 프로세싱이 소프트웨어에서는 그 순서가 바뀔 수 있는 여지가 있었죠.
파이폰은 그걸 허용하지 않습니다. 여기 보면 오너가 있고요.
사이즈랑 엑세스 퍼미션 같은 개념이 있어서요. 여기 여기 이렇게 채널을 해보면 nk 노드에서 채널 해가지고 p 만들면 여기 채널이 생겨요.
이렇게 파일이 여기 p라고 생기죠. 이게 사실 파이프라는 뜻인데 이걸 파이프로 이렇게 만들 파이프가 파이프가 스페셜 타이 파이프라서 필러를 둘이 기본적으로는 리드 바이식이 동일하게 하는데요.
파이프는 순서가 바뀔 수 있죠. 읽어가느냐에 따라서.
근데 54는 반드시 뒤에다 붙여서 읽어가는 순서대로 보장을 해줍니다.
자료 구조의 파이퍼 같은 동작을 보장을 해줘요. 그리고 얘도 렌식이 안 되고 당연히

참석자 1 54:14
l식이 돼버리면 파이프를 제공할 수가 없죠. 나 먼저 들어가 애가 먼저 들어가는 걸 제공을 해버릴 수가 없죠.
해줄 수가 없겠죠. 그래서 mk 54 파 대신에 메이크 54라고 하는 시스템 클로 만들어놓으면 되고요.
얘는 패스 네임을 줘야 돼요. 그리고 럼블라킹 똑같이 세팅해서 쓸 수 있고요.
이그잼플 보면 끝날 건데

참석자 1 54:43
인풋으로 뭘 줬는지 모르겠지만 일단 파이프로 오픈하면 빼지 거예요.
사무실 사무실 그냥 파이퍼 파일을 일단 저 이름으로 오픈을 한 다음에 인풋 되고 메시지 적당히 이 메시지를 받아놓고 그 만들게 그다음에 메시지 버포에다가 복사를 한 다음에 저 파이프에다가 라이트 해요.
그냥 일반 파일처럼 생각하면 되겠죠. 라이 됐으면 그냥 리턴 뭐 하는지 모르겠네.
세드는 있는데 다른 코드가 하나 더 있을 것 같아요.
리스가 이건 다른 프로세스죠 지금 메인이 따로 있죠 얘는 mkb4 가지고서 그 같은 파일 이름을 엽니다.
그러면 얘는 아까 데이터를 누가 넣었잖아요. 그거 열어가지고 리드 안에 데이터 들어가 있어요.
그냥 파일이랑 똑같이 쓰면 되는데 실제로는 파일이 아니고 약간 좀 더 효율적으로 통신을 할 수 있도록 만들어 놓은 파일인데 5는 파이프랑 동일하게 굉장히 옛날 건데 차이점이 있다라면 파이프처럼 소프트웨어 안에서 엑스포시하게 통신하는 게 아니고요.

참석자 1 55:56
약간 파일을 매개체로 해서 데이터 넣어놓고 다른 애는 그 파일에서 읽고 이런 식으로 하기 때문에 먼저 들어간 애가 무조건 먼저 나오게 해줄 수가 있어요.
근데 솔직히 말하면 거의 안 써요. 파이퍼 파이프 정도까지만 잘 알아놓으면 돼요.
파이퍼는 교과서에 있어서 배우긴 하지만 그거 있어요.
우리 지금 이제 교과 과정이 보통 한 4년에 한 번씩 크게 바뀌거든요.
크다고 해봤자 뭐 교과서 보장하기로 하거나 아니면 너무 오래된 과목을 없애고 새로 하거나 할 텐데 뉴스 프로그래밍이 이제 좀 있으면 아마 내년이 4년 차라서 바꿔야 될 때가 돼요.
그럼 아마 파이브 파일 거예요. 파이프는 남아 있을 것 같은데 파이프는 안겨도 되는데 오래된 거라 쓰는 경우도 거의 없고요.
일단은 상식선에서 알아보면 도움이 언젠가는 되겠죠 파이프는 알아놔야 될 거고 여기까지 마지막으로 질문 있을까? 파이프 질문 없으면 과제 얘기합시다.
여기까지 해서 인터포테이스 커뮤니케이션 첫 번째 거 했고요.

참석자 1 57:18
아직 파일은 안 올려놨어요. 근데 이제 이거 끝나고 나서 오늘 올려줄 거니까 여러분들이 뭘 만들 거냐면 이거 오늘 수업 끝나고 한 이유가 파이프 배우에 대해서 친 건데 시그널과 파이프를 실제로 사용을 해볼 겁니다.
근데 사실 진짜 이것도 의미없는 소프트웨어인데 시그널과 파이프를 사용해보라고 낸 과제예요.
뭔가 과제 자체에서 의미를 찾지 말고요. 실제로 써보는 게 거의 의미를 두면 됩니다.
타이머를 만들 건데 페런트라는 차일드를 가지고 멀티 프로세싱으로 만들어야 돼요.
이거는 같은 기능을 구현했어도 제가 지금 얘기하는 기능들을 사용하지 않았다면 점수를 못 받을 거예요.
동작을 하는 게 중요한 게 아니고요. 동작 자체는 의미가 없으니까 방금 얘기해 주신 것처럼 어떤 특정 조건을 맞춰서 구현을 해야 돼요.
페어런트와 차일드 멀티 프로세싱을 구현을 하시고요.
그리고 시그널을 반드시 사용을 해야 됩니다.

참석자 1 58:15
그리고 패널 상 차이 사이에는 파이프로 통신을 해야 되고요.
이 두 가지 제약 사항 기억하시고요. 시그널 써야 되고 파이프를 써야 됩니다.
좀 더 자세하게 그냥 이거 앞에서 이루신 팀으로 다 배웠다라는 내용이고요.
뭐 해야 되냐면 멀티 프로세스 타이머 페어런트랑 차일드가 뭐해야 되는지 저기다가 자세하게 써놨습니다.
과제할 때 요구하시면 되겠는데 페어런트는 파이프를 통해서 차일드로부터 코멘트를 전달받아야 됩니다.
몇 초 몇 초 동안 스톱워치를 해 이런 식으로 그리고 프로세스는 포시를 해야 돼요.
무슨 소리냐면 코멘드 받은 다음에 커멘드를 받은 다음에 그냥 포지를 합니다.
맵다. 그다음에 시그널을 통해서 나중에 차일드가 특정 조건이 되면 잘 깨워줄 거예요.
패런트를. 그래서 웨이크업 해가지고 시그널 처리하면 되는데요.
지금 타이머라고 그랬죠 몇 초 지나면 깨울 거예요 페런트.

참석자 1 59:20
그래서 나는 코멘트 받아서 일단 냅다 잡니다. 그리고 시그널 오면 나 일어났어 몇 초 됐어 하고 프린트 찍어주면 될 거예요.
얘는 커맨드를 유저한테서 받아서 차일드가 몇 초라는 걸 받아서 페어언트한테 넘겨주고 파이프 통해서 넘겨주고요.
몇 초라고 그리고 지금 타이머니까 자라고 알려주는 거예요.
그리고 그 시간 동안 요청된 시간 동안 기다렸다가 시그널 보내면 됩니다.
이거를 구현을 원래 의도한 바라면 지금 뭐를 사용해서 뭘 하라고 다 정해줬죠 근데 똑같은 동작을 사실 패널트가 타이머스면 쉽게 구현이 돼요.
작년에 이 과제를 냈더니 그렇게 구현해 온 학생들이 있었는데 그건 깜짝이에요.
그렇게 하면 뭐가 필요가 없어요 시그널 안 써도 되죠 얘가 그냥 타임 맞춰 쓰면 되니까 그렇게 변하면 안 되고 얘는 요청 들어왔어라는 거 파이프를 알자마자 그냥 냅다 자야 돼.
얘는 아무것도 하면 안 돼요. 얘는 시그널 받고 깨놔서 끝났어 하고 프린트만 해도 되.

참석자 1 1:00:30
실제로 기다리는 건 차이 이해했죠? 그래서 지금 요 동작을 구현을 하려면 차일드랑 페어런트 간에 파이프 통신도 해야 되고 시그널도 써야 됩니다.
둘 다 써야 돼요. 동작을 시키면 이렇게 동작을 하면 됩니다.
1부터 60 사이에 유저 인풋을 아무거나 받으면 그거만큼 출력을 일주일에 한 번씩만 해주면 되겠죠 제가 보는 한 건데 목표를 누르면 5 4 3 2 1 하면 시그널 딱 차이드가 보내서 페런트가 보내서 일어났어.
끝. 구조 알겠죠? 굉장히 굉장히 단순한 구조의 소프트웨어인데 실제로 써보는 게 중요해요.
그러니까 사실은 실습 한 번 더 한다고 생각하면 돼요.
그렇게 어렵지 않아요. 불하시고요. 파이프 통해서 해라.
그러고 나서 시그널 상견례 해가지고 보내라는 얘기고요.
11월 3일까지

참석자 1 1:01:35
목요일이네요. 목요일 날까지. 목요일이 이거 업데이트 안 하는 거구나.
이거 이거 날짜 이대로 잊지 마세요. 내가 업데이트 최소 인력 지금 이 날 줬으니까 8일까지 1일까지 12월 1일까지예요.
금요일까지 지난 작년에 수요일이 놓고 1시 밤 11시 55분까지 금요일 2시 뒤 금요일까지니깐요.
제가 올려놓는 거 보고 확인하시고요. 늦게 제출하지 마세요.
이번에 이번에는 몇 개 받아봤는데 이번에는 정만 안 받아요.
상식선에서 12시 안에 들어오는 것까지만 받아줄게요.
근데 한 1시간 지났어요. 뭐가 문제가 있었어요 이런 거 없으니까 그런 거 생길지도 모르니까 전날 제출한다 생각하시고 하시고요.
제출 시간 안에 하면 5점 그리고 유저 인풋 잘 받아가지고 소프트웨어 시작하면 15점 이것도 거의 기본적이고 파이프 커뮤니케이션 가지고 페어트랑 차일드가 기다리고 있어라라고 알려주는 걸 자유 대응했으면 15점 마지막으로 시그널 가지고 웨이크업해서 프린트 잘 되면

참석자 1 1:02:44
15점 앞에 거 합해서 100점이죠. 첫 번째 과제 50점 이거 50점 해가지고 100점이고요.
중간고사도 100점이고 기말고사도 100점이에요.
그러면 이것도 작은 점수가 아니죠. 별로 어렵지 않으니까 만약에 중간고사 망했으면 집중해서 잘하세요.
질문 있어요 과제 지금 과제가 솔직히 말하면 두려워요.
저기 어렵다고 느끼면 코딩 경험이 부족하구나 생각하시면 되고요.
코딩은 뭐가 됐든지 간에 좀 더 하시면 됩니다. 질문 없으면 오늘 여기까지 할게요.

참석자 1 1:03:57
그럼 어떻게 풀어야

참석자 1 1:04:56
경부선 호텔 몰아 타.

참석자 1 1:05:06
여기 뒤에 사람들 많이 안 좋던데 그래 그냥 핸드폰 하던데 몰라 이렇게 너무 어려운 거 아니야?


clovanote.naver.com